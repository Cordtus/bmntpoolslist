# create a simple js app that will run a query on a timer, parse the response from this and format the output into a new, valid json file of a unified structure, at ./data/pools.json
# the query is as follows: curl -s $(restAddress)/osmosis/poolmanager/v1beta1/pools/$(poolId) | jq ','
# restAddress will come from a list of several addresses, defined in a config module
# upon running the query. any valid json response should be considered successful. If it is not a valid json response, consider that query failed.
# poolId will start at 1, and upon a successful response will parse and format that response, appending it in sequence to the end of the json
# on starting the app, check for existence of ./data/pools.json
# if ./data/pools.json does exist, read and parse .pool.id from the end of file to get the highest .pool.id value - initial poolId is defined as the latest/largest .pool.id + 1
# if ./data/pools.json it does not exist, create it and start the app with poolId=1
# run the query, if a valid response is found parse and format is according to the new struct and write it to ./data/pools.json
# now iterate through each number in sequence, with a 1 second delay between each response and the proceeding query
# if the response is invalid, try again using the next restAddress from config
# if an invalid response is returned 10 times in a row, wait 5 minutes before trying again
# if 3 5 minute waits are triggered consecutively with no success, sleep for 6 hours before trying again
# for each

# when the app is active, it should not need to read the .pool.id each time to determine the next $(poolId)
# assuming a successful query and write of the data, it should loop, each time defining poolId as the pool_id +1 from the previous successful query+addition to the file





# Here are the two most common (valid) responses to expect:

{
  "pool": {
    "@type": "/osmosis.concentratedliquidity.v1beta1.Pool",
    "address": "osmo12f8hx2y5qghfyy6dkqwe70kyptd966x9lf7cw272cap3gcggst9q654m5p",
    "incentives_address": "osmo18wpppl3e0z9u45psrjkv4rjh5ete7y8lsfz9uk02tg5mzex7sgdqzudl50",
    "spread_rewards_address": "osmo1apreqcw0g68t8lyhkcw537k5q6c6aa5nand85u8nhlkyu8wqvqssxttqj9",
    "id": "1220",
    "current_tick_liquidity": "5727348443126890.023294146526034499",
    "token0": "ibc/4ABBEF4C8926DDDB320AE5188CFD63267ABBCEFC0583E4AE05D6E5AA2401DDAB",
    "token1": "ibc/498A0751C798A0D9A389AA3691123DADA57DAA4FE165D5C75894505B876BA6E4",
    "current_sqrt_price": "1.000131328466263587482633582728658765",
    "current_tick": "262",
    "tick_spacing": "100",
    "exponent_at_price_one": "-6",
    "spread_factor": "0.000100000000000000",
    "last_liquidity_update": "2024-03-01T22:27:30.015430760Z"
  }
}


# and


{
  "pool": {
    "@type": "/osmosis.gamm.v1beta1.Pool",
    "address": "osmo1k8393k8jns0pp8652g7mvhykdew35tcz0fu4tezaay3y82uy8ppspz0lp4",
    "id": "1057",
    "pool_params": {
      "swap_fee": "0.002000000000000000",
      "exit_fee": "0.000000000000000000",
      "smooth_weight_change_params": null
    },
    "future_pool_governor": "",
    "total_shares": {
      "denom": "gamm/pool/1057",
      "amount": "32211257158230824017106"
    },
    "pool_assets": [
      {
        "token": {
          "denom": "ibc/56D7C03B8F6A07AD322EEE1BEF3AE996E09D1C1E34C27CF37E0D4A0AC5972516",
          "amount": "97848450435383412780"
        },
        "weight": "5368709120"
      },
      {
        "token": {
          "amount": "687125261621"
        },
        "weight": "5368709120"
      }
    ],
    "total_weight": "10737418240"
  }
}


# Determine pool type from .pool.@type - type should be either "gamm" ("/osmosis.gamm.v1beta1.Pool") or "concentratedliquidity" ("/osmosis.concentratedliquidity.v1beta1.Pool")


# Parse and (where specified) re-label the following from pool type "concentratedliquidity", to be included in the new json -
.pool.@type > .pool.type -- (do not write the full value for this key, shorten it to 'concentratedliquidity')
.pool.id > .pool.id
.pool.token0 > .pool.assets.token0
.pool.token1 > .pool.assets.token1
.pool.spread_factor > .pool.fees.swap_fee
.pool.address > .pool.address


# Parse and (where specified) re-label the following from pool type "gamm", to be included in the new json -
.pool.@type > .pool.type -- (do not write the full value for this key, shorten it to 'gamm')
.pool.id > .pool.id
.pool.pool_assets > .pool.assets
.pool.pool_assets[].denom > pool.assets.token1, pool.assets.token2, pool.assets.token3, <continue for as many assets as are included>
.pool.pool_params > .pool.fees
.pool.pool_params.swap_fee > .pool.fees.swap_fee
.pool.pool_params.exit_fee > .pool.fees.exit_fee
.pool.address > .pool.address


# The actual amount of different tokens in assets will vary from 2-8, this must be taken into account
# This is the struct for the json this data will be written to:

{
  "pools": [
    {
      "type": "",
      "id": "",
      "assets": {
        "token1": "",
        "token2": "",
        "token3": ""
      },
      "fees": {
        "swap_fee": "",
        "exit_fee": ""
      },
      "address": ""
    },
    {
      "type": "",
      "id": "",
      "assets": {
        "token1": "",
        "token2": "",
        "token3": ""
      },
      "fees": {
        "swap_fee": "",
        "exit_fee": ""
      },
      "address": ""
    }
  ]
}







